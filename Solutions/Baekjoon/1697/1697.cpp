#include <bits/stdc++.h>

/*
* BOJ 1697 - 숨바꼭질
*
* [문제 설명]
* 수빈이(N)가 동생(K)을 찾는 최단 시간을 구하는 문제
* 수빈이는 매 시간마다 다음 3가지 움직임 중 하나를 선택할 수 있음:
* 1. 현재 위치에서 한 칸 뒤로 이동 (X -> X-1)
* 2. 현재 위치에서 한 칸 앞으로 이동 (X -> X+1)
* 3. 현재 위치의 2배로 순간이동 (X -> 2*X)
*
* [알고리즘 설명]
* 1. BFS(너비 우선 탐색)를 사용하여 해결
* 2. BFS 선택 이유:
*    - 모든 이동에 걸리는 시간이 1초로 동일
*    - 최단 거리/시간을 구하는 문제이므로 BFS가 최적
*
* [주요 자료구조]
* - dist[100002]: 각 위치까지의 최단 시간을 저장하는 배열
*   - dist[i] = -1: 아직 방문하지 않은 위치
*   - dist[i] = t: 위치 i까지 도달하는데 걸리는 최소 시간 t
* - queue: BFS 구현을 위한 큐
*
* [시간복잡도]
* O(N), 여기서 N은 가능한 위치의 범위 (0 ~ 100,000)
* 각 위치는 최대 한 번만 방문하므로 효율적
*
* [공간복잡도]
* O(N), dist 배열과 큐의 크기
*/

#define X first;
#define Y second;

using namespace std;

// dist 배열: 각 위치까지 도달하는데 걸리는 최소 시간을 저장
// 배열 크기가 100002인 이유: 문제의 제한 조건이 0 ≤ N, K ≤ 100,000이므로, 여유있게 설정
int dist[100002];
int n, k;  // n: 수빈이의 시작 위치, k: 동생의 위치

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    // 시작 위치(n)와 목표 위치(k) 입력 받기
    cin >> n >> k;

    // dist 배열을 -1로 초기화
    // -1은 아직 방문하지 않은 위치를 의미
    fill(dist, dist + 100001, -1);

    // 시작 위치의 소요 시간을 0으로 설정
    dist[n] = 0;

    // BFS를 위한 큐 생성 및 시작 위치 삽입
    queue<int> Q;
    Q.push(n);

    // 동생을 찾을 때까지(k 위치의 거리가 계산될 때까지) BFS 실행
    while (dist[k] == -1) {
        // 현재 위치를 큐에서 추출
        int cur = Q.front(); Q.pop();

        // 현재 위치에서 가능한 3가지 이동 방법을 순회
        // 1. cur-1: 한 칸 뒤로 이동
        // 2. cur+1: 한 칸 앞으로 이동
        // 3. 2*cur: 순간이동 (현재 위치의 2배)
        for (int nxt : {cur - 1, cur + 1, 2 * cur}) {
            // 범위를 벗어나는 경우 스킵
            if (nxt < 0 || nxt > 100000) continue;
            // 이미 방문한 위치인 경우 스킵
            if (dist[nxt] != -1) continue;

            // 다음 위치까지의 소요 시간 = 현재 위치 소요 시간 + 1
            dist[nxt] = dist[cur] + 1;
            // 다음 위치를 큐에 삽입하여 나중에 탐색
            Q.push(nxt);
        }
    }

    // 동생의 위치(k)까지 도달하는데 걸리는 최소 시간 출력
    cout << dist[k];
}